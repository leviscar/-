## Web安全
### XSS
Cross Site Scripting,即跨站脚本。绝大多数XSS攻击都会采用嵌入一段远程或者说第三方域上的脚本资源
#### XSS类型
1. 反射型XSS
   发出请求时,XSS代码出现在URL中,作为输入提交到服务端，服务端解析后响应,在响应内容中出现这段XSS代码,
   最后浏览器解析执行。这个过程就像一次反射，故称为反射型XSS
2. 存储型XSS
   存储型XSS和反射型XSS的差别在于：提交的XSS代码会存储在服务端（不管是数据库、内存还是文件系统等）,下次请求目标页面时不用再提交XSS代码
   最典型的是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示,浏览器发现有XSS代码,就当做正常的HTML与JS解析执行，于是就触发了XSS攻击
3. DOM XSS
   DOM XSS 和反射型XSS、存储型XSS的差别在于，DOM XSS的XSS代码并不需要服务器解析响应的直接参与，触发XSS靠的就是浏览器端的DOM解析，可以认为完全是客户端的事情

#### XSS 防御措施
1. `X-XSS-Protection:[0|1|1;mode:block]`
   - 0 表示禁用这个策略
   - 1 默认，对危险脚本做一些标志或修改，以阻止在浏览器上渲染执行
   - 1;mode=block 强制不渲染,在Chrome下直接跳转到空白页，在IE下返回一个#符号
2. CSP策略 HTML/JS/CSS互相分离，功能也相互独立
   - `X-Content-Security-Policy: [指令1] [指令值1] [指令值2];[指令2] [指令值1] [指令值2]`

3. 域分离
4. 安全传输
5. 安全Cookie
    1. 使用http-only 
6. 优秀的验证码
   
### CSRF
#### Cross Site Request Forgery,即跨站请求伪造
- 攻击的发生是由各种请求造成的。对于CSRF，它的请求有两个关键点，跨站点的请求与请求是伪造的。
- 跨站点的请求，跨站点请求的来源是其他站点，也有可能是来自本站
- 请求是伪造的，一般我们可以认为：如果请求的发出不是用户的意愿，那么这个请求就是伪造的。

#### 跨站请求伪造实例
- 目标网站A  恶意网站B
- 两个域不一样，目标网站A上有一个删除文章的功能，通常是用户单击“删除链接”时才会删除指定的文章，这个链接是`www.a.com/blog/del?id=1`，id号代表不同的文章
- 在恶意网站B上编写一个CSRF页面(www.b.com/csrf.htm)，想想有什么办法可以发一个GET请求到目标网站A上
- 利用AJAX？不行，它禁止跨域传输数据
- 那么，用代码`<img src = http://www.a.com/blog/del?id=1 />`
- 然后欺骗已经登录目标网站A的用户访问`www.b.com/csrf.htm`页面,则攻击发生
- 攻击过程有三个关键点：跨域发出了一个GET请求，可以无JavaScript参与、请求时身份认证后的

#### 攻击方式分类
- HTML CSRF攻击
    - HTML 中能够设置src/href等链接地址的标签都可以发起一个GET请求
    - 通过JavaScript动态生成的标签对象或者是CSS对象（`backgroud： url("")`）发起的GET请求
    - POST请求只能通过form方式提交
- JSON HiJacking 攻击
    - JSON HiJacking 技术非常经典，攻击过程是CSRF，不过是对AJAX响应中最常见的JSON数据类型进行劫持攻击
- Flash CSRF攻击
    - Flash的世界同样遵循同源策略，发起的CSRF攻击是通过ActionScript 脚本来完成，说到Flash CSRF，通常为以下两点
        - 跨域获取隐私数据
        - 跨域提交数据操作，一些如添加、删除、编辑等操作的请求，这里并不会获取到隐私数据

#### CSRF防御措施
1. 检查HTTP Referer字段是否同域
    1. 一般情况下，用户提交站内请求，Referer中的来源应该是站内地址，如果发现Refer而中的地址异常，就可以怀疑遭到了CSRF的攻击
    2. 缺点：对来自站内的CSRF攻击无能为力
2. 限制Session Cookie的生命周期
    1. 比如用户登录网上银行，如果闲置10分钟，则自动销毁Cookie
3. 使用验证码
4. 使用一次性token
6. 
    


### 界面操作劫持
界面操作劫持攻击是一种基于视觉欺骗的Web会话劫持攻击，它通过在网页的可见输入控件上覆盖一个不可见的框(iframe),使得用户误以为在操作可见控件，实际上用户的操作行为被其不可见的框借此，执行不可见框中的恶意劫持代码，从而完成在用户不知情的情况下窃取敏感信息、篡改数据等攻击
#### 攻击类型
- 点击劫持
- 拖放劫持
- 触屏劫持

#### 原理分析
1. 透明层+iframe
    1. 操作劫持技术的核心是在用户可见页面上"覆盖一个不可见的框"，从技术角度来讲，“覆盖”是指控件位置之间的层次关系，“不可见的”是指页面的透明度为零，而“框”则指的是iframe标签，所以“覆盖一个不可见的框”可以理解为“透明层”+“iframe”
    2. 透明层使用CSS样式实现
    3. 使用iframe来嵌入被劫持的页面
2. 点击劫持 只要相应透明层中有按钮的点击事件
3. 拖放劫持复杂  拖放事件时，劫持dataTransfer对象
4. 触屏劫持技术 使用透明层+iframe方法，然后配合触屏设备中自身的API函数来发起触屏劫持攻击

#### 界面劫持防御措施

1. HTTP响应拓展头 `X-Frame-Option:[DENY|SAMEORIGIN]` 
    1. DENY 禁止被加载进任何frame
    2. SAMEORIGIN 仅允许被加载进同域内的frame
2. Frame Busting 脚本防御
    1. 防御操作截止的另一种方法是使用Javascript 脚本来对页面进行控制，达到页面无法被iframe嵌入的目的，这样的防护脚本被称为Frame Busting脚本
3. 使用token进行防御
    1. 如`http://url/login?idtoken=90dfOlk` 如果攻击者无法猜测到idtoken后面的数值，那么这个登录页面就不能被iframe嵌入。进而无法对这个页面实现界面操作劫持攻击
    
    

