## http 协议
### http 1.0 http 1.1 区别
1. **默认支持长连接**  HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。HTTP是基于TCP/IP协议的，创建一个TCP连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。
2. **HTTP 1.1支持只发送header信息** HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。
3. **可拓展性** 
   - 如果HTTP的某个实现接收到了自身未定义的头域，将自动忽略它
   - 在消息中增加版本号，用于兼容性判断。注意，版本号只能用来判断逐段（hop-by-hop）的兼容性，而无法判断端到端（end-to-end）的兼容性。例如，一台HTTP/1.1的源服务器从使用HTTP/1.1的Proxy那儿接收到一条转发的消息，实际上源服务器并不知道终端客户使用的是HTTP/1.0还是HTTP/1.1。因此，HTTP/1.1定义Via头域，用来记录消息转发的路径，它记录了整个路径上所有发送方使用的版本号。
   -  HTTP/1.1增加了OPTIONS方法，它允许客户端获取一个服务器支持的方法列表
   -  为了与未来的协议规范兼容，HTTP/1.1在请求消息中包含了Upgrade头域，通过该头域，客户端可以让服务器知道它能够支持的其它备用通信协议，服务器可以据此进行协议切换，使用备用协议与客户端进行通信
4. **缓存**
   - 在HTTP/1.0中，使用Expire头域来判断资源的fresh或stale，并使用条件（conditional request）来判断资源是否仍有效。例如，cache服务器通过If-Modified-Since头域向服务器验证资源的Last-Modefied头域是否有更新，源服务器可能返回304（Not Modified），则表明该对象仍有效；也可能返回200（OK）替换请求的Cache对象
   - 此外，HTTP/1.0中还定义了Pragma:no-cache头域，客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取
   - HTTP/1.0中，If-Modified-Since头域使用的是绝对时间戳，精确到秒，但使用绝对时间会带来不同机器上的时钟同步问题。而HTTP/1.1中引入了一个ETag头域用于重激活机制，它的值entity tag可以用来唯一的描述一个资源。请求消息中可以使用If-None-Match头域来匹配资源的entitytag是否有变化
   - 为了使caching机制更加灵活，HTTP/1.1增加了Cache-Control头域（请求消息和响应消息都可使用），它支持一个可扩展的指令子集：例如max-age指令支持相对时间戳；private和no-store指令禁止对象被缓存；no-transform阻止Proxy进行任何改变响应的行为
5. **带宽优化**
   - HTTP/1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。
   - HTTP/1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。如果服务器相应地返回了对象所请求范围的内容，则响应码为206（Partial Content），它可以防止Cache将响应误以为是完整的一个对象。
   - 另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。注意，HTTP/1.0的客户端不支持100响应码。但可以让客户端在请求消息中加入Expect头域，并将它的值设置为100-continue。
6. **HOST头域** 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求
7. **错误警告状态码** HTTP/1.0中只定义了16个状态响应码，对错误或警告的提示不够具体。HTTP/1.1引入了一个Warning头域，增加对错误或警告信息的描述。此外，在HTTP/1.1中新增了24个状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除
### http 1.1 http 2.0 区别
1. **多路复用**HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
2. **二进制帧** HTTP1.0利用文本与服务器交互，而HTTP2的基本协议单位为二进制帧流，每帧都有自己的类型旨在实现不同功能，然而HTTP1将继续存在，因此，HTTP2的二进制帧流需映射到HTTP1上以实现向下兼容。
3.  HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的
4.  **数据压缩** HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
5.  **服务器推送** 意思是说，当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。
6.  **HTTP2.0中帧具有优先级** HTTP2帧具有优先级，允许客户端提供排序思路，以让服务器优先处理一部分请求，仍然是以二进制帧的形式返回数据。每个Frame Header中都有一个表示此Frame的 Stream ID，通过stream ID表示可以使所有的请求和响应同时在一条TCP连接上进行，当流并发时，流会有优先级，图片的优先级低于css文件或者js文件的优先级，这样设计可使重要的文件先下载。


### https 
#### SSL 和 TLS
1. SSL-安全套接字层协议 secure socket layer TLS-传输层安全协议 transport layer security
2. 到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。
#### https 建立过程
![](../Images/httpsCreat.png)
最少6次握手
#### 对称加密
对称加密（ symmetric encryption）又称私钥加密（ private-key cryptography），是一种混淆算法，能够让数据在非安全信道上进行安全通信。
- 简单来说，就是通信双方，得到双方都认可的加密算法和密钥。当A需要向B发送数据的时候，A使用密钥对明文进行加密。然后将加密后的加密文档发给B，B使用相同的密钥进行解密，解密后B就可以看到原始文档了。
- 对称加密在高速处理大量数据方面做得非常好，然而随着使用它的团体增加。
    1. **对称加密的缺点**
    2. 每个成员必须共享相同的密钥。人越多，出现问题的概率越大。
    3. 如果要更安全，可以在每两个人之间使用不同的密钥。但是需要的密钥数成指数增长。
    4. 对称加密不能用于访问安全数据的无人系统。
#### 非对称加密
非对称加密又称为公钥加密，使用两个密钥：一个是私钥，一个是公钥。私钥用于私人，公钥被所有人共享。
- 如果你利用某人的公钥加密数据，那么只有他们对应的私钥能够解密。
- 如果某人用私钥加密数据，任何人都可以利用对应公钥解开消息。这种操作不具私密性，主要用来做数字签名。